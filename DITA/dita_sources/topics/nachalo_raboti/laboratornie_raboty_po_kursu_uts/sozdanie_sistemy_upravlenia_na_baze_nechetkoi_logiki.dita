<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_x5n_gv5_qf">
  <title>МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ СОЗДАНИЕ СИСТЕМЫ УПРАВЛЕНИЯ НА БАЗЕ НЕЧЁТКОЙ ЛОГИКИ  </title>
  <shortdesc>ЛАБОРАТОРНАЯ РАБОТА №8 по курсу «Управление в технических системах» </shortdesc>
  <body>
    <p>ВВЕДЕНИЕ</p>
    <p>ЦЕЛЬ РАБОТЫ</p>
    <p>1 ОСНОВЫ ТЕОРИИ НЕЧЕТКОЙ ЛОГИКИ</p>
    <p>1.1 Нечеткая логика – это просто</p>
    <p>1.2 Принцип построения алгоритма нечеткого вывода</p>
    <p>2 СОЗДАНИЯ РЕГУЛЯТОРА НА БАЗЕ НЕЧЕТКОЙ ЛОГИКИ В SIMINTECH</p>
    <p>2.1 Встроенный язык программирования</p>
    <p>2.2 Фазификация – простой пример</p>
    <p>2.3. Создание собственной библиотеки блоков.</p>
    <p>2.4. Дырявый бак, управляемый нечеткой логикой</p>
    <p>2.5. Создание правил регулирования.</p>
    <p>2.6. Аккумуляция и дефазификация в одном флаконе </p>
    <p>3 АНИМАЦИЯ БЛОКА НЕЧЕТКОЙ ЛОГИКИ.</p>
    <p>3.1 Задание параметров нового блока.</p>
    <p>3.2 Анимация блока, опять скрипт</p>
    <p>3.3 И моделируем, и рисуем</p>
    <p>4 ГЕНЕРАТОР КОДА НА ЯЗЫКЕ СИ</p>
    <p>4.1 Что это и зачем это нужно?</p>
    <p>4.2 Настраиваем генерацию кода для новых блоков</p>
    <p>4.3 Генерация кода Си или программист не нужен</p>
    <p>Заключение.</p>
    <p> </p>
    <p/>
    <p> </p>
    <p><b>ВВЕДЕНИЕ</b></p>
    <p>Среда динамического моделирования технических систем SimInTech, являться инструментом для
      создания математических моделей любых систем, описание которых может быть представлено в виде
      система алгебраических и дифференциальных уравнений в общих производных. SimInTech содержит в
      себе развитые инструменты обеспечивающие расширение возможностей по моделированию процессов, в
      данной работе рассматривается пример создания собственной библиотеки блоков.</p>
    <p>В данной работе рассматривается процесс создания алгоритмов управления на базе «нечеткой
      логики» в среде динамического моделирования технических систем «SimInTech». Показаны методы
      создания собственных блоков на базе встроенного в SimInTech языка программирования.
      Демонстрируется возможность генерации кода Си управляющих программ.</p>
    <p> </p>
    <p><b><ph id="_Toc360285166">ЦЕЛЬ РАБОТЫ</ph></b></p>
    <ul id="ul_wl4_nj2_qy">
      <li>· демонстрация процесса создания собственных блоков для SimInTech встроенными
        инструментами.</li>
      <li>· ознакомление с новыми методами формирования математических моделей динамики САР в
        программном комплексе "SimInTech", включая:</li>
      <li>o процедуры создания новых блоков с помощью языка программирования;</li>
      <li>o создание собственных библиотек блоков;</li>
      <li>o создание технической анимации на изображении блоков;</li>
      <li>o генерация кода Си;</li>
      <li>· ознакомление с основами создания управляющих блоков на базе нечеткой логики,
        включая:</li>
      <li>o фазификацию переменных;</li>
      <li>o формирование математической модели базы правил нечеткого вывода;</li>
      <li>o аккумуляцию, агрегацию и нечеткий вывод.</li>
    </ul>
    <p><b>1 ОСНОВЫ ТЕОРИИ НЕЧЕТКОЙ ЛОГИКИ</b></p>
    <p><b>1.1 Нечеткая логика – это просто</b></p>
    <p>В классической теории автоматического управления, управляющее воздействие на систему
      рассчитывается в зависимости от регулируемой величины, выраженной в численном виде и система
      управления производит преобразование входных параметров в управляющие воздействия передаточным
      функциями (рассчитываемым по алгоритмам в цифровых системах, либо на основе физическим
      приводов в аналоговых системах управления)</p>
    <p>Нечеткая логика это принцип построения алгоритмов управления на базе системы логических
      правил, аналогичных классической логике. При данном подходе управляющие воздействие
      рассчитывается на основе набора правил типа:</p>
    <p><b>Если</b><i>(входной параметр) </i><b>то</b><i> (управляющее воздействии)</i>;</p>
    <p><b>Если</b><i>(входная параметр 1)</i><b>и</b> (<i>входной параметр
        2)</i><b>то</b><i>(управляющее воздействи)</i>;</p>
    <p>Например, для регулирования температуры воды в смесители эти правила могут выглядеть так:</p>
    <p><b>1. </b><b>E</b><b>сли </b><i>вода горячая</i><b> то </b><i>открываем кран холодной
        воды</i><b>;</b></p>
    <p><b>2. Eсли </b><i>вода холодная</i><b> то </b><i>открываем кран горячей воды</i><b>;</b></p>
    <p><b>3. Eсли </b><i>вода холодная</i><b> и </b><i>кран горячей открыт полностью</i><b>, то
        </b><i>закрываем кран холодной воды</i><b>;</b></p>
    <p><b>4. Eсли </b><i>вода горячая </i><b>и </b><i>кран холодной воды открыт полностью</i><b>, то
        </b><i>закрываем кран горячей воды</i><b>.</b></p>
    <p>Как видно из примера управляющее воздействие определяется не в виде вычисления от температуре
      воды, а в виде логического анализа утверждений.</p>
    <p>Основная проблема построения алгоритмов на базе нечеткой логике перейти от параметров системы
      к логическим утверждениям, как для входных величин (перейти от измеренной температуры к
      утверждению <i>вода горячая</i>), так и для регулирующего воздействия (перейти от <i>открываем
        кран </i>к углу поворота, или скорости вращения вентиля).</p>
    <p>Именно процессы это перехода мы разберем в данной лабораторной работе.</p>
    <p><b>1.2 Принцип построения алгоритма нечеткого вывода</b></p>
    <p>Для того, чтобы можно было применять простые правила, данные, передаваемые в блок
      регулирования на основе нечеткой логики, должны быть преобразованы. Для этого предлагается
      следующие:</p>
    <p>Входные параметры и выходные воздействия преобразовываются в <b>лингвистические
        переменные</b>. Каждая лингвистическая переменная характеризуется набором <b>термов</b>.
      Например лингвистическая переменная <b>температура</b> может иметь следующие термы
        "<i>холодно</i>", "<i>нормально</i>", "<i>горячо</i>". Лингвистическая переменная уровень
      может иметь следующие термы: "<i>низкий</i>", "<i>нормальный</i>", "<i>высокий</i>".
      Лингвистическая переменная <b>команды задвижки </b>может иметь следующие термы "<i>открывать
        быстро</i>", "<i>открывать медленно</i>", "<i>не трогать</i>", "<i>закрывать медленно</i>",
        "<i>закрывать быстро</i>". Каждый терм описывается своей <b>функции
        принадлежности</b><i>µi(x),</i> которая может принимать значения от 0 до 1. Получив значение
      входной переменной x в блоки нечетко логики вычисляется значения <i>µi(x)</i> каждого терма.
      Это процедура называется термином <b>Фазификация</b>.</p>
    <p>Результатом применения правила являются величина, называемая степенью истинности, а попросту
      число от 0 до 1. Что бы было понятно рассмотрим пример: Пусть есть задвижка которая
      открывается по сигналу уровня и простое правило:</p>
    <p>Если <b>уровень</b><i>низкий </i>то <b>команда задвижки</b> - <i>открывать быстро</i>.</p>
    <p>У нас есть входная величина уровень <b>h</b> в метрах. Если величина уровня низкая
        (<i>µlow</i>(h) = 1, где µlow(h) - <i>функция принадлежности</i> для <b>
        терма</b><i>низкий</i>), или уровень не низкий ((<i>µlow</i>(h) = 0), то все происходит как
      и в обычной логике, степень истинности правила принимает значение 1 или 0. Нечеткость
      начинается если 0 &lt; <i>µlow</i>(h) &lt; 1, например = 0.5. Уровень низкий, но не очень.
      Соответственно и открывать задвижку нужно быстро, но не очень. В данном правиле <i>степень
        истинности</i> равна 0.5. Подобным образом происходит ее вычисления для каждого правила.</p>
    <p>Этот процесс называется <b>Активизация</b>.</p>
    <p>Заключения из каждого правила собираются вместе для каждой лингвистической переменной, этот
      процесс называется <b>Аккумуляця</b>. Например после расчета набора правил, мы получаем
      результаты для лингвистической переменной <b>задвижка: </b>"<i>открывать быстро</i>" - 0.5,
        "<i>открывать медленно</i>" - 0.3, "<i>не трогать</i>" - 0, "<i>закрывать медленно</i>"-0,
        "<i>закрывать быстро</i>"-0. Понятно, что скорость задвижки лежит где то между медленной и
      быстро.</p>
    <p>Зная степень истинности для каждого терма выходной переменной можно рассчитать ее числовое
      значение. Эта процедура называется <b>Дефазификацией</b>.</p>
    <p>Таким образом работа блока управления на базе нечеткой логики может быть разбита на следующие
      этапы:</p>
    <ul id="ul_xl4_nj2_qy">
      <li>1. Фазификация входных переменных.</li>
      <li>2. Активизация заключений правил нечеткой логики.</li>
      <li>3. Аккумуляция заключений для каждой лингвистической переменной.</li>
      <li>4. Дефазификация выходных переменных.</li>
    </ul>
    <p>Все эти этапы мы и выполним в SimInTech с помощью встроенного языка программирования.</p>
    <p> </p>
    <p><b>2 СОЗДАНИЯ РЕГУЛЯТОРА НА БАЗЕ НЕЧЕТКОЙ ЛОГИКИ В SIMINTECH</b></p>
    <p><b>2.1 Встроенный язык программирования</b></p>
    <p>В 2004 году в SimInTech появился новый блок - <i>язык программирования</i>. Данный блок
      позволяет создавать собственные модели в виде программы, выполняемой на каждом шаге расчета.
      Таким образом можно формировать любые модели, описание которых существует виде системы
      алгебраических и дифференциальных уравнений, без компиляции непосредственно в среде SimInTech.
      В языке программирования поддерживается все основные конструкции языков высокого уровня, а так
      же содержится большой набор математических функций, который постоянно расширяеться.</p>
    <p>Внешний вид SimInTech с открытым окном редактора языка программирования представлен на рис.
      2.1. Новый блок по умолчанию находится в закладке Динамические. Редактор языка
      программирования открывается по двойному клику на блоке в схемном окне.</p>
    <p><image href="labwork8/image002.png" height="626" width="1043" id="image_yl4_nj2_qy"
      /></p>
    <p>Рис. 2.1. Вид окна языка програмирования</p>
    <p>.</p>
    <p><b>2.2 Фазификация – простой пример</b></p>
    <p>Для в качестве первого примера выполним фазификацию входной переменной. Наш блок, на вход
      будет получать 1 значение и оценивать его, насколько данная величина, соответствует заданным в
      параметрах термам, например <i>большая</i>, <i>нормальная</i> или <i>малая. </i>Мы будем
      расчленять исходную величину на несколько термов, рассчитывая для каждого терма <i>функцию
        принадлежности</i>.</p>
    <p>Создайте новую схему автоматики и настройте параметры расчета. Установите время моделирования
      20 сек. Для этого нужно залезть в меню <b><i>Расчет/Параметры расчета</i></b> и найти строку
      как <b><i>Конечное врем расчета</i></b>. Для расчета с максимальной скоростью, на закладке
        «<i>Синхронизация</i>» снимете галочку «<i>Синхронизировать с реальным временем</i>» см.
      рис. 2.2</p>
    <table id="table_zl4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image003.png" height="502" width="435"
                id="image_am4_nj2_qy"/></entry>
            <entry><image href="labwork8/image004.png" height="501" width="437"
                id="image_bm4_nj2_qy"/></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Рис. 2.2. Настройка параметров расчета</p>
    <p>Поместите на схему три блока: Из закладки <b>Источники</b> возьмите блок
        <b><i>Линейный</i></b>, из закладки Данные возьмем блок <i>Временной график</i>, ну и
      наконец, самый интересный для нас блок из линейки <b>Динамические</b> – блок <i>Язык
        программирования</i>.</p>
    <p>Наша задача выполнить фазификацию переменной. Роль входной переменной будет играть линейный
      источник.</p>
    <p>Переменная у нас будет меняться от -1 до 1. Для этого установите параметры блока <i>Линейный
        источник:</i></p>
    <p><i>Свободный член</i> -1;</p>
    <p><i>Коффициент при </i><i>t</i> - 0.1.</p>
    <p>Откройте редактор блока языка программирования двойным кликом на блоке в схеме. Снесите весь
      текст, который там есть по умолчанию. И напишете простейшую программу - текст как показано на
      картинке 2.3</p>
    <table id="table_cm4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image005.png" height="230" width="549"
                id="image_dm4_nj2_qy"/></entry>
            <entry><image href="labwork8/image006.png" height="489" width="826"
                id="image_em4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис. 2.3. Программа блока</entry>
            <entry>Рис. 2.4. Окно SimInTech после расчета модели</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Закройте окно, нажав на кнопку с зеленной галочкой справа вверху. После закрытия видим, что у
      блока появились <i>входной</i> и <i>выходной</i> порты. На вход подайте сигнал из блока
      линейный. Ну а для того, чтобы было, куда подключить выход блока, в свойствах графика
      увеличьте количество <i>входных портов</i> до 2 и соедините выход блока программирования с
      графиком. Запустите расчет и на графике должен быть косой крест как на рисунке 2.4 Входная
      переменная возрастает - выходная переменная убывает.</p>
    <p>Ну вот в принципе вы сделали свой первый блок-программу, которая инвертирует вход. Теперь
      сделаем полезную вещь, а именно, расчет <i>функции принадлежности <b>µ(x)</b><b>типа кривой
          Гаусса</b></i>. Формула для расчета известна: <image href="labwork8/image007.png"
        height="54" width="145" id="image_fm4_nj2_qy"/>. Чтобы запрограмировать эту формулу,
      необходимо ввести в программу две переменные: с и sigma, и записать код для расчета
      кривой.</p>
    <p>Измените текст в блоке язык программирования на следующий:</p>
    <p><image href="labwork8/image008.jpg" height="79" width="260" id="image_gm4_nj2_qy"/></p>
    <p>Для увеличения наглядности используйте блок <i>фазовый портрет</i> из закладки <b>Данные</b>.
      К верхнему входу <i>фазового портрета</i> подключите выход линейного блока, а к нижнему –
      выходы <i>языка программирования</i>. См. рисунок 2.5. Запустите расчет, на графиках появилась
      «шишка», см. рис. 2.6.</p>
    <p>Две переменный <b><i>с</i></b> и <b><i>sigma</i></b> определяют вид кривой: <b><i>с</i></b> -
      это значение, при котором <i>функция принадлежности</i> равна единице - верхушка шишки.
          <b><i>Sigma</i></b> – параметр ширины шишки.</p>
    <p>Таким образом мы получили блок, который позволяет рассчитывает <i>функцию принадлежности</i>
      для входной величины. Из графиков видно, что в момент времени, когда входная переменная х =
      0.5 (наклонная кривая) функция принадлежности равна единице, и чем больше х отличается от 0.5
      тем меньше <i>функция принадлежности</i>. Имея такой блок уже сейчас можно скопировать его на
      схеме получать разные функции принадлежности для разных термов задавая разные значения
          <b><i>с</i></b> и <b><i>sigma</i></b>.</p>
    <p> </p>
    <table id="table_hm4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image009.png" height="146" width="311"
                id="image_im4_nj2_qy"/></entry>
            <entry><image href="labwork8/image010.jpg" height="213" width="403"
                id="image_jm4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис. 2.5. Схема для расчета функции принадлежности</entry>
            <entry>Рис. 2.6. Графики расчета функции принадлежности</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Для сокращения количества блоков на схемы, мы сделаем из одного сигнала три терма с тремя
      функциями принадлежности в одном блоке.</p>
    <p>Для этого запишем функцию принадлежности как функцию. Измените текст на следующий:</p>
    <p><image href="labwork8/image011.png" height="175" width="423" id="image_km4_nj2_qy"
      /></p>
    <p>Запустите на счет и убедитесь, что ничего не изменилось. А теперь воспользуемся тем
      счастливым обстоятельством, что в SimInTech почти всё, что может быть векторезировано,
      является вектором. Следовательно, и переменные могут быть векторами. Пусть, в базе правил
      нечеткой логике используем три <b>терма</b>: <i>низкий, нормальный</i> и <i>высокий</i>.
      Соответственно вместо одного значения на выходе нужно три, каждый из которых показывает
      насколько величина является, <b>низкой,</b><b>нормальной</b> или <b>высокой</b>. Делается это
      легко и не принужденно.</p>
    <p>Переоопределим переменные <b>с,</b><b>sigma </b>и выход <b>у</b> в массивы из трех элементов
      соответственно <b>c[3], sigma[3], у[3]</b>. Запишем для каждого трема свои параметры функции
      принадлежности. И для сокращения вычислений сделаем присвоение значений переменным в блоке
      инициализации (между слов <b>initialization</b> и <b>end</b>). Это блок выполняется только
      одни раз при запуске расчета, незачем повторять присвоение на каждом шаге интегрирования. А
      теперь в цикле ровно три раза, вызовем функцию принадлежности. Текст всего этого приведен
      ниже:</p>
    <table id="table_lm4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image012.png" height="403" width="446"
                id="image_mm4_nj2_qy"/></entry>
            <entry>
              <p>Если сейчас нажать на кнопку старт, то SimInTech покажет вам ошибку и сообщит что
                не может привести в соответствие какие-то размерности. Дело в том, что фазовый
                портрет должен иметь на обоих портах одинаковую размерность, а у нас переменная,
                попавшая в <i>язык программирования</i> расплодилась. Необходимо, размножить
                переменную подаваемую на верхний вход фазового портрета. Возьмите в закладке
                    <b><i>Векторные</i></b> блок <i>размножитель</i>, и поместите его на схему, как
                показано на рисунке 2.., а в качестве параметров запишите 3#1. Теперь переменная
                преобразуется в вектор из трех одинаковых значений и фазовый портрет работает (см.
                рис. 2.8).</p>
              <p>Вот и все, с помощью каких то 15 строчек кода мы выполнили фазификацию переменной
                на три терма. Сохраните эту модель, в дальнейшем можно использовать эту схемы для
                проверки работы кода, для фазификации переменной другими функциями принадлежности.
                Результаты моделирования представлены на рис. 2.8.</p>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p> </p>
    <table id="table_nm4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image013.png" height="138" width="305"
                id="image_om4_nj2_qy"/></entry>
            <entry><image href="labwork8/image014.jpg" height="214" width="402"
                id="image_pm4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис. 2.7. Схема демонстрации фазификации</entry>
            <entry>Рис. 2.8. Результаты работы блока фазификации</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Посмотри еще раз на дело рук своих. Мы создали блок который обеспечивает анализ входной
      переменной и ее разложение на 3 терма (низкий, нормальны, высокий) (фазификацию). В данном
      примере приянто, что -1 это <i>низкий</i> (low), 0, это <i>нормальный </i>(normal), 1 это
        <i>высокий </i>(high). В нашей тестовой схеме переменная меняется от – 1 до 1. Запустив
      расчет, мы наглядно видим, как линейные изменения одной переменной от – 1 до 1 приводят к
      изменению значений трех термов, в диапазоне от 0, до 1. В начале когда входная величина равна
      -1, терм <i>низкий </i>имеет функцию принадлежности = 1, термы <i>нормальный </i>и<i> высокий
      </i>равны нулю. По мере роста входной величины, значение терма <i>низкий </i>уменьшается
      (величина еще низкая но уже не так), а значение терма <i>нормальный</i> начинает расти, чем
      ближе к 0, тем ближе значение терма <i>нормальный </i>к <i>1</i>. Так на наших глазах, простой
      рост входной величины от -1 до 1, не имеющий никакой наглядности, превратился в наглядный
      жизненный процесс перехода от <i>низкий</i>, через <i>нормальный</i> к <i>высокий. </i>А с
      этими значениями уже можно формировать правила логического вывода.</p>
    <p> </p>
    <p><b>2.3. Создание собственной библиотеки блоков.</b></p>
    <p>В среде SimInTech вы можете создавать свои библиотеки, которые могут продаваться как решение
      третих сторон. Покажем как это делается на примере библиотеки нечеткой логики. На предыдущем
      этапе мы создали блок который осуществляет фазификацию входной переменной на три терма,
      понятно, что меняя константы в коде мы можем фазифицировать переменную на любое количество
      термов.</p>
    <p>Сейчас создадим блок, в котором пользователь будет задавать сколько нужно ему термов и какие
      значения им соответствуют. Что бы не изменить, то что уже работает, в SimInTech первым делом
      необходимо сменить название класса блока. Войдите в Свойства блока «<i>Язык
        программирования»,</i> который мы с вами сделали ранее, и замените тип элемента дав ему
      название «<b>Фазификация Гаусса</b>» (см. Рис. 2.9) Теперь при сохранении этого блока в
      библиотеку, мы не изменим существующий блок «<i>Язык программирования</i>».</p>
    <table id="table_qm4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image015.png" height="139" width="436"
                id="image_rm4_nj2_qy"/></entry>
            <entry><image href="labwork8/image016.png" height="377" width="409"
                id="image_sm4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис. 2.9. Именуем новый блок</entry>
            <entry>Рис. 2.10. Переводим систему в режим разработчика</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>После того как тип элемента переименован, можно приступить его редактированию. Для начала
      нужно перевести SimInTech в режим разработчика. Заходим в главное меню программы пункт
        «<i>Файл</i>» подпункт «<i>Параметры</i>» В появившемся окне нужно поставить галочку в опции
        «<i>Режим разработчика</i>» (Рис. 2.30).</p>
    <p>В режиме разработчика выделяем блок «<i>Язык программирования</i>» на схеме и переходим к
      главному меню программы «<i>Правка</i>» в самом низу находится подпункт «Изменить блок», в
      диалоговом окне необходимо снести все свойства, кроме свойства «<i>Транслировать скрипт в код
        автоматически</i>». (Данное свойство обеспечит нам возможность получить Си код из блока.)
      После этого добавить новые как показано на Рис. 2. 11. Для удаления и добавления используются
      кнопки внизу справа. В качестве свойств блока мы задаем <b>Количество термов</b>,<b>Mассив
        значений с</b>, и<b> Массив значений </b><b>sigma. </b>Тут же мы даем значения по умолчанию
      (см. Рис. 2.11).</p>
    <table id="table_tm4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image017.png" height="257" width="813"
                id="image_um4_nj2_qy"/></entry>
            <entry><image href="labwork8/image018.png" height="214" width="379"
                id="image_vm4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис 2.11. Свойства блока фазификация, заданные разработчиком блока</entry>
            <entry>Рис 2.12. Свойства блока фазификация</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Нажимаем кнопку окей. Если вы все сделали правильно, у нашего блока в свойствах появились
      ровно те же поля. Что бы посмотреть и поменять свойства, выделите блок, кликните правой
      кнопкой мыши, в всплывающем меню и выберите пункт «<i>Свойства объекта</i>». В окне выберите
      закладку «<i>Свойства</i>» (см. Рис 2.12). И вот оно счастье, меняйте параметры и получайте
      разнообразные фазификации в любом количестве.</p>
    <p>Перейдем в окно редактирования скрипта и изменим текст нашей программы с учетом, того что у
      нас появились новые переменные которые будут задавать счастливые пользователи нашего
      блока.</p>
    <p>Вместо задания переменных в тексте программы сделаем присвоении их из переменных, заданных
      пользователем. Добавляем защиту от отрицательного ввода кол-ва термов. Защита от дурака не
      когда не мешала, хотя нельзя предусмотреть изобретательность дурака. Сделаем еще одну защиту
      от выхода входной величины за границу диапазона.</p>
    <p>Поясню, если входная величина равна границе диапазона, то согласно алгоритму значения функции
      принадлежности для крайних термов равно единице. Однако, при выходе за границу диапазона
      значение функции принадлежности начнет уменьшатся, шишка Гаусса идет на убыль. Очень часто,
      это является ошибкой. Например, входная температура разбита на три терма: <b>холодно</b> +10
      C, <b>нормально</b> +30 C, и <b>горячо</b> +55 C. Если температура 55 С это на 100%
        <b>горячо</b> (функция принадлежности = 1), и по правилам логики нужно максимально быстро
      крутить кран холодной воды, то при температуре 100 C, явно нужно делать тоже самое, хотя
      функция гаусса в этой точке может превратится в ноль. Чтобы этого не случилось введена
      проверка выхода значения входной величины за границу диапазона. Текст всего это лежит приведен
      ниже.</p>
    <table id="table_wm4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image019.png" height="483" width="454"
                id="image_xm4_nj2_qy"/></entry>
            <entry namest="col2" nameend="col3">
              <p>Теперь, если сохранить этот блок и запустить на расчет модель, графики должны быть
                точно такими как на на рис. 2.8. Если это так, то поздравлю вы только что
                разработали новый блок для SimInTech и сделали первый шаг к тому что бы стать
                миллионером. Что бы убедиться в этом чуде, поменяйте свойства блока на другие и
                посмотрите какие графики у вас рисуются. Например, для 5 термов, при параметрах
                заданных для блока, как на рисунке 2.13, у вас и графики похожи, то вы все сдерали
                правильно.</p>
              <p>Теперь можно заносить этот блок в библиотеку, но перед этим изменим его свойства,
                что бы он был более похож на стандартные блоки. Выделите блок на схеме, правой
                кнопкой мыши вызовите всплывающее меню и выберите пункт «<i>Свойства объекта</i>» .
                В окне выберите закладку «<i>Общие</i>» В нижней части списка свойств можно изменить
                  «<i>Графическое изображение</i>» блока. Рекомендую так же установить <b>Да</b> для
                свойства «<i>Блокировка доступа</i>». В этом случае, при двойном клике по блоку на
                схеме будет вызываться окно свойств, а не текст программы (см. рис. 2.14), который
                уже настолько хорош, что не требует правки со стороны пользователя блока.</p>
            </entry>
          </row>
          <row>
            <entry namest="col1" nameend="col2"><image href="labwork8/image020.png"
                height="417" width="596" id="image_ym4_nj2_qy"/></entry>
            <entry><image href="labwork8/image021.png" height="456" width="412"
                id="image_zm4_nj2_qy"/></entry>
          </row>
          <row>
            <entry namest="col1" nameend="col2">
              <p>Рис. 2.13. Фазификация на 5 термов функция гаусса</p>
              <p> </p>
            </entry>
            <entry>Рис. 2.14 Настройка блока фазификация перед добавлением в библиотеку</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Для занесения блока в библиотеку, выделяем его на схеме и в главном окне выбираем пункт меню
        «<i>Файл</i>» подпункт «<i>Сохранить в библиотеку</i>».</p>
    <p>(Я бы еще рекомендовал «<i>Сохранить в файл</i>», что бы потом продавать это файл). Блок
      сохранился в библиотеку, но мы пока его не видим в линейке. Еще раз меню «<i>Файл</i>», потом
        «<i>Редактировать библиотеку</i>». Пролистываем столбец «<i>Все записи</i>» и в самом низу
      находим наш блок «<i>Фазификация Гаусса</i>» (см. Рис. 2.15):</p>
    <p><image href="labwork8/image022.png" height="464" width="900" id="image_an4_nj2_qy"
      /></p>
    <p>Рис. 2.15 Создание новой закладки “Нечетка Логика”</p>
    <p>Ну вот последние клики мышкой добавляем страницу палитры “<i>Нечеткая Логика</i>” переносим в
      нее наш блок, на закладке «<i>Свойства</i>», задаем ему картинку и вуаля, у вас в палитре
      новая библиотека. (См. Рис. 2.16):</p>
    <p><image href="labwork8/image023.png" height="145" width="862" id="image_bn4_nj2_qy"
      /></p>
    <p>Рис. 2.16. Новая линейка блоков.</p>
    <p>SimInTech позволяет создавать совой блоки и в виде схемы, в данной работе мы рассматривали
      создание блока на базе «<i>Языка программирования</i>», но тоже самое можно было сделать на
      базе блока «<i>Субмодель</i>» используя стандартную библиотеку блоков в, например так выглядит
      схема реализующая блок «<i>Фазификация Гаусса</i>» в виде схемы:</p>
    <p><image href="labwork8/image024.png" height="340" width="826" id="image_cn4_nj2_qy"
      /></p>
    <p><b>2.4. Дырявый бак, управляемый нечеткой логикой</b></p>
    <p>Прежде, чем перейти к овладению следующим этапам работы алгоритма нечеткой логики, сделаем
      объект управления. Управлять будем уровнем в дырявом баке. Задача проста как в школе про
      бассейн, в одну трубу вливается в другую выливается. Мы будем управлять расходом входа, а
      утечка будет происходить самотеком.</p>
    <p>Параметры бака: высота - 2 м; Площадь сечения - 1 м; Диаметр выходного отверстия 0.05 м2.</p>
    <p>Создайте новый проект, поместите на схему «<i>Субмодель</i>» из закладки
      «<i>Субструктуры</i>». Войдите в блок, переключитесь на закладку «Скрипт» схемного окна и
      введите данные по баку:</p>
    <table id="table_dn4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image025.png" height="209" width="470"
                id="image_en4_nj2_qy"/></entry>
            <entry>
              <p>Динамику бака можно описать следующими уравнениями:</p>
              <p><image href="labwork8/image026.gif" height="155" width="201"
                  id="image_fn4_nj2_qy"/></p>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>где: <b>V </b>- объем бака м3; <b>rate</b> - расход поступающий в бак м3/с; <b>outrate</b> -
      расход утечки м3/с; <b>h</b> - уровень в баке м; <b>area</b> - площадь сечения бака;
        <b>outarea</b> - площадь выходного отверстия; <b>g = 9.81</b> - ускорение свободного
      падения.</p>
    <p>Бросьте на схему наш любимый блок «Язык программирования» и запишите уравнения динамики:</p>
    <table id="table_gn4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image027.png" height="157" width="370"
                id="image_hn4_nj2_qy"/></entry>
            <entry>Вот, чем особенно хорош блок Язык программирования SimInTech, теперь пользователь
              как узбек (что вижу, о том пою) что видит, то и моделирует. Если уравнения динамики
              известны, их нужно просто записать, не забывая указывать начальные условия для
              динамических ременных. Обратите внимание что уравнение для производной записываться
              так же как и обычные уравнения в языке программирования, отличие только в знаке ‘
              после имени переменной.(строка <b>V’ = </b><b>rate - </b><b>outrate</b>). Так же для
              дифференциальной переменной необходимо задать начальные условия (здесь <b>init
              V=0</b>) и все, после этого динамика модели ядром SimInTech.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Соберите схему, вокруг модели, как показано на рисунке и модель бака дырявого бак готова.</p>
    <p><image href="labwork8/image028.png" height="97" width="480" id="image_in4_nj2_qy"/></p>
    <p>Рис. 2.17. Cхема субмодели дырявого бака</p>
    <p>Разберемся теперь с клапаном управляющим расходом. Основная идея такова. Задается
      номинальный̆ расход 0.5 м3/с. Управляющие воздействие это скорость закрытия-открытия
      задвижки, интегрируя данную скорость мы получаем положение задвижки - число от 0 (задвижка
      закрыта - расход равен 0) до 1 расход равен номинальному. Зависимость расхода от положение
      задвижки линейная. Бросьте на основную схему новый <i>блок «Субмодель» </i>из закладки
        <b>Субструктуры </b>войдите в него и соберите схему как на рис. 2.18:</p>
    <table id="table_jn4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image029.png" height="62" width="322"
                id="image_kn4_nj2_qy"/></entry>
            <entry><image href="labwork8/image030.jpg" height="138" width="526"
                id="image_ln4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис. 2.18. Cхема субмодели клапана</entry>
            <entry>Рис. 2.19. Общая схема модели</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Теперь модель объекта управления типа дырявый бак, готова к работе. Осталось положить на
      схему недостающие блоки, для задания уровня, отображения результатов. Конечная схема модели,
      вместе с регуляторному уровня на базе нечеткой логики будет выглядеть следующим как на рисунке
      2.19.</p>
    <p>Работа системы проста и незатейлива. Блок «<i>Меандр</i>» из закладки «Источники» задает
      изменение уровня с частотой 20 сек с 1.5 до 0.5 и обратно, заданное значение сравнивается с
      реальным и разница подается на первый вход блока управления. На второй вход подается скорость
      изменения уровня в баке. На выходе мы получаем команду клапана который и управляет расходом в
      бак.</p>
    <p><b>2.5. Создание правил регулирования.</b></p>
    <p>Получив модель дырявого бака, самое время перейти к рассмотрению базы правил нечеткой логики.
      Для нашего бака правила блок управления на базе нечеткой логики имеет входные лингвистические
        переменные<b>уровень</b><b>, </b>и<b> изменение уровня.</b> Переменная <b>уровень</b> будет
      иметь следующие термы: 1<i> -высокий</i>, 2<i> -нормальный</i>, 3<i> -низкий</i>. Переменная
      изменение уровня будет иметь такие термы: 1 - <i>уменьшается</i>, 2<i> -не изменяется</i>, 3
        -<i>увеличивается</i>. Блок управления клапаном будет выдавать лингвистическую переменную
        <b>команда клапана, </b>которая в свою очередь, будет иметь следующие термы<b>: </b>1
        -<i>закрывать быстро,</i> 2 -<i>закрывать медленно</i>, 3 <i>-не менять,</i> 4 <i>-открывать
        медленно,</i> 5 <i>- открывать быстро.</i> База правил для управления будет иметь следующий
      вид:</p>
    <p>1. <b>ЕСЛИ</b><b>уровень</b><i>= высокий</i><b>TO</b><b>команда клапана</b><i>= закрывать
        быстро</i>;</p>
    <p>2. <b>ЕСЛИ</b><b>уровень </b><i>= нормальный</i><b>TO</b><b>команда клапана =</b><i>не
        изменять</i>;</p>
    <p>3. <b>ЕСЛИ</b><b>уровень</b><i>= низкий</i><b>ТО</b><b>команда клапана =</b><i>открывать
        быстро</i>;</p>
    <p>4. <b>ЕСЛИ</b><b>уровень</b><i>= нормальный </i><b>И</b><b>изменение уровня </b>= уменьшается
        <b>ТО</b><b>команда клапана =</b><i>открывать медленно</i>;</p>
    <p>5. <b>ЕСЛИ</b><b>уровень</b><i>= нормальный </i><b>И</b><b>изменение уровня </b>=
      увеличивается <b>ТО</b><b>команда клапана =</b><i>закрывать медленно</i>;</p>
    <p>Как видим на словах все абсолютно ясно и просто. Поскольку логика у нас нечеткая, для каждого
      правила нужно, не просто получить ответ да или нет, а рассчитать степь истинности. Для правил
      1-3 степень истинности равна величание функции принадлежности для соответствующего терма.
      Попросту, если уровень h <i>высокий</i> на 0.5 (µhigh(h) = 0.5) то и степень истинности
        <i>закрывать быстро</i> равна 0.5. Функциональная схема макроблока реализующего данное
      правило:</p>
    <p><image href="labwork8/image031.png" height="90" width="295" id="image_mn4_nj2_qy"/></p>
    <p>Константа вес позволяет задать весовой коэффициент для правила в общей базе правил. Создайте
      новую субмодель, и повторите данную схему, после этого данный блок можно положить в библиотеку
      блоков.</p>
    <p>Степень истинности правил 4 и 5 зависит от двух входных переменных, соединенных логическим И,
      по научному можете называть это логической конъюнкцией. Для вычисления степени истинности
      существует несколько вариантов, мы используем метод алгебраического произведения смотри схему
      субмодели:</p>
    <p><image href="labwork8/image032.png" height="131" width="393" id="image_nn4_nj2_qy"
      /></p>
    <p>Эту субмодель тоже можно положить в библиотеку готовых блоков на страницу нечеткая логика.
      Так вы постепенно приближаетесь к созданию собственной бибилиотеке. Имея всего три блока в
      библиотеке можно уже начинать собирать систему управления на базе нечеткой логики. Возьмите
      блоки из нашей новой библиотеки и соберите схему как показано на рисунке 2.20.</p>
    <p><image href="labwork8/image033.png" height="278" width="792" id="image_on4_nj2_qy"
      /></p>
    <p>Рис. 2.20. Cхема регулятора на базе нечеткой логики.</p>
    <p>На рисунке 2.10 картинки блоков для наглядности изменены, что совсем не влияет на
      функциональное наполнении блока. Возьмите блоки из библиотеке и перетащите их на схему.
      Задайте параметры фазификации Гауса для переменной <b>уровень</b>:</p>
    <p><i>Количество термов</i> = 3, <i>Массив значений с</i> = [-1,0,1], <i>Массив значений
        </i><i>sigma</i> = 3#0.3 (три раза по 0.3);</p>
    <p>для переменной <b>скорость изменения:</b></p>
    <p><i>Количество термов</i> = 3, <i>Массив значений с</i> = [-0.1,0,0.1], <i>Массив значений
        </i><i>sigma</i> = 3#0.03 (три раза по 0.03);</p>
    <p>Самая большая сложность на этом этапе, это соединение блоков фазификации и блоков правил в
      нужном порядке. Вот здесь и пригодится возможность подписывать блоки. Выход из блока
      фазификации для каждой переменной соедините с блоком <i>Демультиплексор, </i>для удобства
      дальнейшей работы с базой правил, подпишите под блоком соответствующие название термов в том
      порядке в котором они расположены в веторе. Ибо ORDNUNG, ORDNUNG UBER ALLES, как говорят
      немцы.</p>
    <p>Поместите на схему необходимое количество блоков правил.</p>
    <p>Выходная переменная имеет пять термов их мы будем предавать в виде вектора. Поместите на
      схему блок Мультиплексор и задайте 5 входных параметров. Подписи под блоком помогут правильно
      подключить результаты блоков правил. Помните ORDNUNG, ORDNUNG UBER ALLES!</p>
    <p>Соедините схему согласно записанных правил, как показано на рис. 2.20. И сохраните
      заготовку.</p>
    <p><b>2.6. Аккумуляция и дефазификация в одном флаконе</b></p>
    <p>Получив вектор состоящий из пяти заключений из правил нечеткой логики, необходимо рассчитать
      значение выходной переменной. Для этого мы воспользуемся алгоритмом Мамдани.</p>
    <p>Для начала осуществим фазификацию выходной переменной на пять термов с помощью треугольных
      функций принадлежности. Как Вы уже догадались мы снова будем пользовать блок Язык
      программирования. Первая часть текста программы приведена на рисунке 2.21</p>
    <p><image href="labwork8/image034.jpg" height="184" width="426" id="image_pn4_nj2_qy"
      /></p>
    <p>Рис. 2.21. Треугольная функция принадлежности для термов вывода</p>
    <p>action[5] - это массив входных значений (заключений из базы правил), который в процессе
      моделирования мы получим из блока Демультиплексор;</p>
    <p>var x=0; объявление переменной для тестирования функции, непосредственно в окне
      реадактора.</p>
    <p>TriangleFM - треугольная функция принадлежности.</p>
    <p>Записав данный кусок кода не плохо бы проверить, что мы нагородили, и тут нам на помощь
      средства проверки зависимостей в языке программирования SimInTech. Для этого мы и ввели
      переменную x, потом ее можно удалить после завершения тестирования.</p>
    <p>За что инженеры-физики уважают MachCad? Не в последнюю очередь за то, он позволяет проверить
      что расчет, непосредственно в процессе записи. В любой момент можно построить графическую
      зависимость и посмотреть не припущено-ли где возведение в степень, не стоил ли знак плюс
      вместо минуса или умножение вместо деления. А вот при программировании постоянно приходится,
      вооружившись дебаггером, шерстить код на предмет ошибок..</p>
    <p>Чтобы убедится в отсутствии багов в написанном куске кода, построим график функции. Для этого
      нажмите на кнопку <image href="labwork8/image035.png" height="28" width="29"
        id="image_qn4_nj2_qy"/> «<i>построить графическую зависимость</i>». При этом появится
      диалоговое окно построения зависимости как на рис. 2.22, Вообще то это окно предназначено для
      обработки векторных данных, но если поставить галочку в окошке Скалярная зависимость, то
      "легким движением руки шорты превращаются в ..." графопостроитель. В верхней строке задаете
      минимальное, максимальное значения по оси их X и количество точек графика. В нижнем
      записываете функцию которую только что запрограммировали. Нажимаете кнопку ОК и видите
      результат как на рис. 2.22:</p>
    <table id="table_rn4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image036.jpg" height="318" width="454"
                id="image_sn4_nj2_qy"/></entry>
            <entry morerows="1">
              <p>Теперь меняя значения параметров функции (a,b,c) и нажимая кнопку ОК можно получать
                графики функции при различных параметрах.</p>
              <p>Следующая часть листинга приведена на рисунке 2.23. Здесь описываются параметры
                необходимые для нечеткого вывода:</p>
              <ul id="ul_tn4_nj2_qy">
                <li>§ Количество термов выходной величины;</li>
                <li>§ Минимальное и максимальное значение аргумента функции выходной переменной (оно
                  же является диапазоном для численного интегрирования).</li>
                <li>§ Массивы переменных для треугольных функции фазификации выходной
                  переменной.</li>
                <li>§ Относительную точность интегрирования.</li>
                <li>§ Рассчитываем шаг интегрирования.</li>
              </ul>
            </entry>
          </row>
          <row>
            <entry>Рис. 2.22. Проверка работы функции графопостроителем.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Для удобства дальнейшей проверки присваиваем значения входному вектору action. (Дело в том,
      что до начала расчета значения входных переменных в векторе action[5] равны нулю. В процессе
      расчета эти значения получаются из входного расчета. Для проверки кода без запуска
      моделирования можно присвоить им проверочные значения, если это сделать в секции
      initialization, то в последствии это присвоение можно не удалять так как на расчет они не
      повлияют.</p>
    <table id="table_un4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image037.png" height="419" width="574"
                id="image_vn4_nj2_qy"/></entry>
            <entry>
              <p>Параметры a[i], b[i], c[i], задаются с учетом расположения заключений правил в
                входном векторе смотри рис 2.10. В примере принято расположение термов по
                возрастанию. В принципе, расположение может быть любое. Главное соблюдать
                соответствие между индексом терма в векторе входа, и индексом параметров функции
                принадлежности терма.</p>
              <p> </p>
            </entry>
          </row>
          <row>
            <entry>Рис.2.23. Задание параметров для нечеткого вывода</entry>
            <entry> </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p> </p>
    <p>Соответствие термов и параметров их функций принадлежности приведены в таблице:</p>
    <table id="table_wn4_nj2_qy">
      <tgroup cols="3">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <colspec colnum="3" colname="col3"/>
        <tbody>
          <row>
            <entry><b>Index</b></entry>
            <entry><b>Терм</b></entry>
            <entry><b>Параметры функции принадлежности</b></entry>
          </row>
          <row>
            <entry><i>1</i></entry>
            <entry><i>закрывать быстро</i></entry>
            <entry> (-1, -0.9, -0.8)</entry>
          </row>
          <row>
            <entry><i>2</i></entry>
            <entry><i>закрывать медленно</i></entry>
            <entry>(-0.6, -0.5, -0.4)</entry>
          </row>
          <row>
            <entry><i>3</i></entry>
            <entry><i>не изменять</i></entry>
            <entry>(-0.1, 0, 0.1)</entry>
          </row>
          <row>
            <entry><i>4</i></entry>
            <entry><i>открывать медленно</i></entry>
            <entry>(0.3, 0.4, 0.5)</entry>
          </row>
          <row>
            <entry><i>5</i></entry>
            <entry><i>открывать быстро</i></entry>
            <entry>(0.8, 0.9, 1)</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>На рис. 2.23 показано заполнение параметров функций фазификация выходной переменной по
      термам, согласно таблице. Следующая процедура заключается в применении заключений из правил
      нечеткой логики. Данная процедура называется<b> активизация</b>.</p>
    <p>Есть несколько методов активизации мы воспользуемся методом prod-активизации, при этом
      результирующая функция получается умножением степени истинности заключения из правила на
      соответствующую функцию принадлежности. Например если <b>степень истинности</b> для
        заключения<i> закрывать быстро</i> равна <b>0 </b>(первое значение в массиве <b>action</b> )
      то после умножения функция принадлежности превратится в ноль.</p>
    <p>Одновременно с <b>активизацией</b> мы проведем <b>аккумуляцию - </b>найдем общую функцию
      принадлежности для выходной переменной по всем термам. Мы строим общую функцию для заданного
      диапазона значений. Для этого, функцию принадлежности каждого терма µi(x) нужно умножить на
      значение <b>степени истинности</b> соответствующего заключения (<b>активизация</b>), и найти
      максимальное значение из всех таких произведений для каждого терма в т. x
      (<b>аккумуляция</b>). В результате мы получаем огибающую функцию. Алгоритм вычисления проведен
      ниже.</p>
    <p><image href="labwork8/image038.png" height="177" width="558" id="image_xn4_nj2_qy"
      /></p>
    <p>Если сейчас запустить построитель зависимостей и построить зависимость для AccProb, то мы
      получим график как на рис. 2.24. Функция объединила все треугольники теремов, при этом высота
      треугольников, стала зависеть от значения вектора action, значения которого мы присвоили в
      секции инициализации (см. рис. 2.23) во время моделирования эти значения будут поступать из
      блоков расчета правил нечеткой логики, и в каждый момент времени моделирования высота
      треугольников будет соответствовать результатам логического агрегирования, соответствующих
      правил.</p>
    <p><image href="labwork8/image039.jpg" height="312" width="335" id="image_yn4_nj2_qy"
      /></p>
    <p>Рис.2.24. Расчет аккумулирующей функции</p>
    <p>Таким образом, получив на вход 5 значений вычисления логических правил, и имея треугольные
      функции принадлежность мы создаем кривую из которой мы должны получит единственно значение
      выходной величины, для в алгоритме Мамдани, предлагается вычислить центр тяжесть полученной
      фигуры. Кривая у нас в виде функции AccProb(х) и мы находим центр масс полученной фигуры. Для
      этого нам и пригодится значение dX, рассчитанное в секции <b>initialization</b> блока см.рис.
      2.23 Формула расчета центра масс проста:</p>
    <p><image href="labwork8/image040.gif" height="124" width="150" id="image_zn4_nj2_qy"
      /></p>
    <p>Ну, а численный алгоритм реализующий эту формулу методом треугольников представлен на рисунке
      2.25.</p>
    <p><image href="labwork8/image041.png" height="325" width="509" id="image_a44_nj2_qy"
      /></p>
    <p>Рис.2.25. Дефазификация методом Мамдани.</p>
    <p>Если вы правильно переписали листинги кода с рисунков выше по тексту, то при запуске расчета,
      на графике, подписанном нами как уровень, из основной схемы, (смотри рис. 2.19.) отразится
      изменения заданного уровня (синий график) и уровня обеспечиваемого регулятором нечеткой логики
      (красный график):</p>
    <p><image href="labwork8/image042.png" height="405" width="698" id="image_b44_nj2_qy"
      /></p>
    <p>Рис. 2.26 Работа регулятора на базе нечеткой логике для регулирования уровня в дырявом
      баке.</p>
    <p>Поздравляю! Вы только что своими руками создали регулятор на базе нечеткой логики. Для этого
      Вам пришлось написать около 70 строчек кода. При этом Вы мимоходом, получили три блока которые
      могут пригодится при решении подобных задач в будущем. После выполнения это лабораторной
      работы, Вы можете спокойно начинать изучение нечеткой логики, пользуясь любым учебником. Вы
      теперь знает, что нечеткая логика это не просто, а очень просто особенно с SimInTech.
      Удачи!</p>
    <p>Но это еще не все, поскольку SimInTech это не Simulink, более передовая система мы в
      следующем разделе покажем как можно еще улучшить наш блок, перед тем как помещать его в
      библиотеку блоков.</p>
    <p><b>3 АНИМАЦИЯ БЛОКА НЕЧЕТКОЙ ЛОГИКИ.</b></p>
    <p>Вот что мне не хватает в этом волшебном блоке, созданным за пару часов? А не хватает
      наглядности. Например если я ошибся в цифрах, запятую не там поставил. Есть конечно
      программисты, которые как в матрице, глядя в цифры видят там голую женщину. И это хорошо, но
      для решения задачи желательно видеть женьщину, а форму кривой которую мы задаем в виде цифр, и
      желательно до моделирования, и SimInTech это обеспечивает. Сейчас покажу как.</p>
    <p><b>3.1 Задание параметров нового блока.</b></p>
    <p>В п. 2.3 описано, как создавать новый блок. Из нашего блока мы создаем новый задав ему имя
      «Вывод треугольными функциями». Что бы он стал универсальным, вы выносим параметры треугольных
      функция из текста программы в свойства блока, туда же отправляем в качестве параметров,
      количество термов, максимальное и минимальное значение выходной величины. Как это сделать см.
      п.2.3. В итоге свойства блока должны выглядеть так как на рис. 3.1 Значения по умолчанию берем
      из значений заданных в секции инициализации.</p>
    <p>Свойство «<i>Транслировать в код автоматически</i>» оставляем из свойств блока «<i>Язык
        программирования</i>» (см п.2.3) нам это свойство пригодиться в дальнейшем.</p>
    <p>Как только вы задали эти свойства для блока, становиться абсолютно не нужным объявление этих
      переменных в тексте программы и можно смело их удалять. Секция инициализации программы
      сократиться до трех строчек кода:</p>
    <p><image href="labwork8/image043.jpg" height="66" width="269" id="image_c44_nj2_qy"/></p>
    <p>Для анимации блока нам еще нужна переменная - вектор входных значений, полученных из правил
      нечеткого вывода, а так же параметр, равный результату нечеткого вывода. Их можно добавить их
      в закладке параметры окна «Редактирования блока» блока. см. Рис 3.2, параметры отличаются от
      свойств тем, что их не пользователь задает, а сам блок рассчитывает.</p>
    <p> </p>
    <p><image href="labwork8/image044.png" height="388" width="813" id="image_d44_nj2_qy"
      /></p>
    <p>3.1 Свойства блока нечеткого вывода треугольными функциями.</p>
    <p><image href="labwork8/image045.png" height="204" width="813" id="image_e44_nj2_qy"
      /></p>
    <p>Рис. 3.2 Параметры блока нечеткого вывода треугольными функциями.</p>
    <p>В тексте программы блока добавляем присвоение этим переменным:</p>
    <p><image href="labwork8/image046.png" height="67" width="132" id="image_f44_nj2_qy"/></p>
    <p>Таки образом мы подготовили все для начала работы с анимационной системой SimInTech.</p>
    <p>В принципе, все что мы будем делать дальше не будет относится к расчету и блок можно закрыть
      для доступа. Для этого в свойствах блока мы устанавливаем поле «<i>Блокировка доступа</i>» -
        <b>Да</b>. После этого двойной клик по блоку будет вызывать окно свойств блока, а не текст
      скрипта. Потом всегда можно снять блокировку и поправить там, если что то пойдет не так.</p>
    <p>Для того что бы оживить наш блок устанавливаем свойство «<i>Анимированный</i>» - <b>Да</b>. В
      этом случае во время расчета будет вызваться и исполняться скритп на встроенном языке
      программирования, обеспечивающий анимацию изображения блока.</p>
    <p>Установив эти поля, переходим в режим редактирования графического изображения блока, для
      этого в поле «<i>Графическое изображение</i>» кликаем по кнопке вызова редактора. (см. рис
      3.3)</p>
    <p><image href="labwork8/image047.png" height="164" width="414" id="image_g44_nj2_qy"
      /></p>
    <p>Рис. 3.3. Настройки блока нечеткого вывода</p>
    <p>Внешний вид редактора изображен на рис. 3.4. Кроме этого на рисунке присутствует «<i>Панель
        примитивов</i>» из которых можно собрать любое изображение (даже картину), если есть
      художественный вкус. Тут же на рисунке есть окно редактирования объекта «<i>Свойства</i>», в
      котором можно задать свойства этих примитивов. (см. рис 3.4)</p>
    <p>Для вызова панели примитивов используется пункт меню «<i>Вид</i>» подпункт «<i>Панель
        примитивов</i>», редактор «<i>Свойства</i>» вызывается нажатием правой кнопки мыши, при
      любом выделенном объекте в «<i>Графическом редакторе</i>». На рис. 3.4 нарисована
      объект-примитив линия и показаны ее свойства.</p>
    <p>Для успешного рисования нужно понимать, что окно редактирования содержит в себе, все то
      пространство, которое будет помещено в рамки блока на схеме. Все что ваше воображение нарисует
      в этом окне, будет нарисовано и на блоке в соответствующем масштабе. Вы можете настроить
      размер этого окна и масштаб отображения в нем любым способом как вам удобно.</p>
    <p>Открыв это окно сотрите все, что там есть, нам это не пригодится, настройте размеры как вам
      удобно рисовать и проведите линию по диагонали. Зачем? Все просто, в свойствах это линии,
      можно прочитать размеры окна в условных единицах измерения. В моем случае свойства линии
        «<i>Координаты точек</i>» показывают что высота данного прямоугольника по оси Y - 32 (от 16
      до -16), а ширина по оси Х - 48 (от -24, 24). Таким образом можно догадаться что, центр
      координат находится в центре, а самое главное я теперь знаю, что для того чтобы мое
      изображение влезло в прямоугольник блока на схеме, оно должно быть иметь размер не больше (32
      Х 48). После этого линию можно удалить.</p>
    <p> </p>
    <p><image href="labwork8/image048.png" height="510" width="1017" id="image_h44_nj2_qy"
      /></p>
    <p>Рис. 3.4. Проверка размеров изображения блока.</p>
    <p>Для того, что бы наш блок мог отобразить функции принадлежности, нам необходимо передать в
      скрипт все параметры, по которым они рассчитываются. Делается это просто. В «<i>Графическом
        редакторе</i>» выберем пункт меню «<i>Сервис</i>» далее подпункт «<i>Cигналы</i>», в
      появившемся диалоговом окне мы можем задать сигналы, которые будут использованы скриптом для
      рисования. Имена сигналов могут быть произвольными, но если задать имена сигналов совпадающих
      с свойствами блока, то автоматически их значения, во время расчёта будут забираться из свойств
      блока, что нам и требуется, поэтому просто повторяем, то что у нас есть в свойствах и не
      забываем параметры, который мы специально сделали и присвоили в скрипте блока для этой цели
      a_in и Y_res. (см. рис. 3.5)</p>
    <p><image href="labwork8/image049.png" height="261" width="637" id="image_i44_nj2_qy"
      /></p>
    <p>Рис. 3.5. Сигналы передаваемые в скрипт для построения изображения.</p>
    <p><b>3.2 Анимация блока, опять скрипт</b></p>
    <p>После того как вы подготовил сигналы для скрипта перейдем непосредственно к программированию
      анимации. Пункт меню окна «<i>Графический редактор</i>», «<i>Сервис</i>» подпункт
        «<i>Скрипт</i>» нажимаем и что мы видим? Да, да, это тоже самое окно языка программирования,
      в котором мы уже прогали математику нечеткой логики. И мы точно так же будем сейчас прогать
      анимацию, пользуясь тем же самым языком программирования. Все отличие заключается в том, что
      этот скрипт не рассчитывает выход блока по входу, а управляет окном анимации. И использует
      сигналы которые мы только что задали.</p>
    <p>Для начала подготовим переменные и функции.</p>
    <p>Переменные <b>X</b><b>_</b><b>g</b><b>[3],</b><b>Y</b><b>_</b><b>g</b><b>[3]</b> будут
      содержать координаты точек, в системе координат графического блока, по которым мы будем
      строить функции. Переменные <b>dX, dY, KX, KY</b>, это коэффициенты пересчета из значений
      функций в математическом блоке в значения координат на графическом изображении блока.
      Константы ширины и высоты блока мы выяснили когда проводили линию по диагонали (см. Рис
      3.4).</p>
    <p> </p>
    <p><image href="labwork8/image050.png" height="305" width="610" id="image_j44_nj2_qy"
      /></p>
    <p><image href="labwork8/image051.png" height="337" width="455" id="image_k44_nj2_qy"
      /></p>
    <p>Рис. 3.6 Координатная сетка графического окна блока.</p>
    <p>Для того что бы пересчитать величины расчетные в масштаб блока посмотрим на рисунок 3.6.
      Точка 0,0 находится в центре прямоугольника, направление координат показано красными стрелками
      (см. Рис. 3.6).Проще всего с координатой Y, поскольку функция принадлежности меняется от 0 до
      1, то коэффициент масштабирования KY = - RH/1 (минус, потому что ось Y в графическом окне
      направлена вниз, см. Рис. 3.6), а для того что сдвинуть О к нижней границе блока DY =
      RH/2.</p>
    <p>Для оси X коэффициент масштабирования KX = RW/(MaxX-MinX), а что бы сдвинуть MinX к левой
      границе блока нужно от текущего значения отнять DX = (MinX+(MaxX-MinX)/2)*KX (см. Рис. 3.6)
      Таким образом значение MinX окажется на левой границы изображения. Что бы не вычислять на
      каждом шаге коэффициенты мы это сделаем в секции инициализации. В итоге текст будет такой:</p>
    <p><image href="labwork8/image052.png" height="170" width="689" id="image_l44_nj2_qy"
      /></p>
    <p>Ну и наконец, мы выполнив расчет коэффициентов можно начать рисовать треугольники. И рисовать
      мы будем не из примитивов и руками, а как настоящие программисты из скрипта и функциями.
      Задайте следующий текст в секции инициализации:</p>
    <table id="table_m44_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image053.jpg" height="105" width="393"
                id="image_n44_nj2_qy"/></entry>
            <entry><image href="labwork8/image054.jpg" height="134" width="153"
                id="image_o44_nj2_qy"/></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Что делают эти строчки понятно из рисунка треугольной функции. Мы выбрали первую треугольную
      функцию <b><i>i</i></b><b><i>=1 </i></b>и рассчитали координаты трех точек с помощью
          функций<b><i> Х</i></b><b><i>grah</i></b>и <b><i>Ygraph</i></b><b><i>, </i></b>а потом
      создали примитив полигон использую стандартную функцию<b><i> createprimitiv </i></b>передав
      ему координаты точек в качестве параметров. Закройте окно нажав кнопку «<i>Применить</i>»,
      закройте «<i>Графический редактор</i>», на вопрос «<i>Сохранить изображение?</i>» отвечайте
      да, и будет вам чудо как на рис. 3.7 (Блок увеличен для наглядности). В поле блока вдруг
      откуда не возьмись появлялся треугольник построенный по точкам, заданным в параметрах блока и
      отмасштабированный в размер блока.</p>
    <p><image href="labwork8/image055.png" height="283" width="512" id="image_p44_nj2_qy"
      /></p>
    <p>Рис. 3.7. Блок с треугольной функцией</p>
    <p>Если теперь менять значения a[1], b[1], с[1] в параметрах блока, то каждый раз будет
      рисоваться новый треугольник. Вернемся в графический редактор блока и удалим все что мы
      нарисовали.</p>
    <p><b>3.3 И моделируем, и рисуем</b></p>
    <p>Завершим создания анимации блока работы нечеткой логики.</p>
    <p>И начнем мы в секции инициализации, и начнем с того что сотрем все что еще не нарисовали,
      поскольку каждый раз при инициализации и изменений параметров будут создаваться новые
      полигоны, нужно удалить старые что бы не загромождать поле:</p>
    <p><image href="labwork8/image056.png" height="193" width="689" id="image_q44_nj2_qy"
      /></p>
    <p>Данный кусок кода обратным счетом обходит все объекты и проверяет их имена, если имя содержит
      строку «<b>Polygon</b><b>_</b>», то мы удаляем это объект. Так же в этом куске кода мы удаляем
      линию, нарисуем ее позднее. Теперь наверняка все чисто и можно нарисовать столько термов,
      сколько задано в параметрах.</p>
    <p>Создавая новые полигоны, мы присваиваем им имена начинающиеся на строку «<i>Polygon</i><i>_»,
      </i>это позволит нам в дальнейшем найти и удалить их при следуещей инициализации.</p>
    <p>Поскольку мне не направиться зеленый цвет, я в коде меняю его на синий, и убираю линию
      границы полигона, мне она тоже не нравиться в итоге у меня получается следующий код:</p>
    <p><image href="labwork8/image057.png" height="284" width="498" id="image_r44_nj2_qy"
      /></p>
    <p>Полигоны и треугольные функции это хорошо, но я хочу еще получить на схеме оценку выходной
      функции. Для этого я создаю линию, которая покажет, где между максимум и минимум находиться
      результат нечеткого вывода:</p>
    <p><image href="labwork8/image058.png" height="116" width="491" id="image_s44_nj2_qy"
      /></p>
    <p>На этом создание изображения блока закончено, закроем секцию инициализации словом
      <b>end;</b></p>
    <p>Если сейчас сохранить скрипт и закрыть окно подтвердив сохранения изображения, то изображение
      на схеме будет отображать наглядно параметры фазификации блока нечеткого вывода (см. Рис.
      3.8).</p>
    <p><image href="labwork8/image059.png" height="246" width="485" id="image_t44_nj2_qy"
      /></p>
    <p>Рис. 3.8. Изображение блока фазификации</p>
    <p>Ну и последний штрих оживление этих треугольников в процессе расчета. Текст см. ниже.</p>
    <p>Все просто, если у нас проект находиться в состоянии расчёта, мы для каждого терма готовим
      массив точек треугольника, учитывая значения входных функций, тут-то и пригодилась переменная
      a_in – она определяет высоту треугольника. По имени находим соответствующий полигон и
      устанавливаем ему новые точки.</p>
    <p>С линией поступаем еще проще пересчитываем, координаты по результату вывода Xgraph(Y_res) и
      передвигаем ее в нужное положение. Если вы все сделали правильно, то ваш блок во время расчета
      отображает состояние нечеткого вывода. Что бы это увидеть установите синхронизацию в
      параметрах расчета (кнопочка <image href="labwork8/image060.png" height="21" width="23"
        id="image_u44_nj2_qy"/> в верху схемы, справа) с реальным времени и шаг вывода результата
      0,005 (иначе расчет проскакивает так быстро что ничего не успеть увидеть)</p>
    <p> </p>
    <p><image href="labwork8/image061.png" height="341" width="564" id="image_v44_nj2_qy"
      /></p>
    <p><image href="labwork8/image062.png" height="153" width="378" id="image_w44_nj2_qy"
      /></p>
    <p>Рис. 3.9. Настройка синхронизации с реальным временем</p>
    <p> </p>
    <p><image href="labwork8/image063.jpg" height="456" width="935" id="image_x44_nj2_qy"
      /></p>
    <p> </p>
    <p>Поздравляю вы теперь не только создали блок нечеткого вывода но и создали наглядную анимацию
      работы этого блока непосредственно на схеме, в процессе расчета и подготовки данных.</p>
    <p>Так же наглядно показано как просто создавать новые крутые блоки в SimInTech.</p>
    <p>Но и это еще не все. Далее мы покажем как создать код Си из нашего блока.</p>
    <p> </p>
    <p><b>4 ГЕНЕРАТОР КОДА НА ЯЗЫКЕ СИ</b></p>
    <p><b>4.1 Что это и зачем это нужно?</b></p>
    <p>Дело в том, что SimInTech, хоть и работает под Linux, но является системой дорогой, сложной
      идеально предназначенной для моделирования и научного анализа моделей сложных систем и
      алгоритмов управления ими. Инструмент выско-интеллектуальных ученых. А у практиков инженеров
      напрашивается идея, если мы так классно и быстро слепили алгоритм управления, в нельзя ли его
      так же и запихнуть в систему управления, прямо из SimInTech? С радостью отвечаю на этот вопрос
      – можно!</p>
    <p>Схема алгоритма созданная в среде SimInTech может быть преобразована в код на языке Си. А уже
      код может быть скомпилирован под любую операционную систему или целевую платформу, для которой
      существует компиляторы. Таки образом мы можем отлаженную схему превратить в программу, которая
      работает везде, где можно запускать программы скомпилированные из языка Си. Наша схема может
      быть преобразована в исполняемый кода или динамическую библиотеку и запущена:</p>
    <ul id="ul_y44_nj2_qy">
      <li>· в составе среды SimInTech;</li>
      <li>· в совместно или в составе сторонней моделирующей программы;</li>
      <li>· контроллерах реальной системы управления.</li>
    </ul>
    <p>Именно так создают программы для управления атомными реакторами, сначала рисуют схемы в
      SimInTech, а потом, по нажатию волшебной кнопки, генерируют код Си, компилируют ее в программу
      и заливают в контроллер управления. Генератор Си в среде SimInTech сертифицирован, для
      генерации кода в системах важных для безопасности АЭС.</p>
    <p>С другой стороны, если вдруг вы создали что-то невероятно умное и полезное, и не хотите чтобы
      вашу внутреннюю структуру подсмотрели пользователи, вы можете преобразовать ваши модели в код
      Cи, собрать библиотеку для SimInTech и поставлять их заказчикам в виде dll, что бы они не
      раскрыли ваши технологические секреты.</p>
    <p>И, наконец, третья причина использования кода Cи это ускорение расчета в 20 – 200 раз, в
      зависимости от типа модели.</p>
    <p><b>4.2 Настраиваем генерацию кода для новых блоков</b></p>
    <p>В SimInTech из расчетной схемы можно создать код Си, если схема создана из блоков в
      стандартной библиотеке блоков, то Си получается просто нажатием кнопки. Для блока созданного
      своим руками на языке програмирования есть два способа:</p>
    <ul id="ul_z44_nj2_qy">
      <li>1) просто написать текст Си и разложить в поля свойств блока «<i>Язык
        программирования</i>». (см. Рис 4.1)</li>
      <li>2) Указать <b>Да</b> для свойства «<i>Транслировать в код автоматически</i>»</li>
    </ul>
    <p>Именно поэтому выполняя пункт 2.3 мы снесли все свойства оставив только одно, если снесли, то
      вернуть его обратно, можно путем копирования у блока «Язык программирования» (см. Рис 4.1)</p>
    <p><image href="labwork8/image064.png" height="438" width="811" id="image_ap4_nj2_qy"
      /></p>
    <p>Рис. 4.1. Свойства блока отвечающие за генерацию кода</p>
    <p><image href="labwork8/image065.png" height="294" width="591" id="image_bp4_nj2_qy"
      /></p>
    <p>Рис. 4.2. Свойства блока нечеткого вывода с добавленным пунктом по генерации кода</p>
    <p>Установите для этого значения «Да» для всех блоков, на схеме созданных с помощью языка
      программирования. Убедившись, что у все наших новых блоков, созданных с использованием языка
      программирования есть «<i>Транслировать скрипт в код автоматически</i>» и оно установлено в
      «Да» можно перейти к генерации кода.</p>
    <p><b>4.3 Генерация кода Си или программист не нужен</b></p>
    <p>Для создания кода, мы будем использовать внутренности субмодели «Блок управления на базе
      нечеткой логики», войдите в него выделите все блоки и скопируйте их в буфер обмена.</p>
    <p>Создайте новый проекта (Меню «<i>Файл</i>»/ «<i>Схема автоматики</i>»), вставьте в него
      скопированные блоки и сохраните под именем «fl_controller.prt», в той же папке где лежит
      полная модель. Все что у нас на данной схеме будет преобразовано в код Си и помещено в dll,
      для того чтобы эта dll могла работать в состав схемы необходимо объяснить ей, что у нас вход,
      а что выход, нужно заменить входы и выходы.</p>
    <p>Необходимо заменить блоки «<i>Порты входа</i>» «<b><i>Уровень</i></b>» и
        «<b><i>Расход</i></b>» на блоки «<i>входной контакт </i><i>S3</i>», расположенные в закладке
        «<i>Данные</i>», а блок «Порт выхода» «Выход» заменить на блок «<i>выходной контакт
        </i><i>S3</i>». В свойствах контактов нужно указать ключевые слова «<b><i>input:0</i></b>»
      для первого входа (уровень) и «<b>input:1</b>» для второго входа (расход). Для выходного
      контакт имя должно быть указано как «<b><i>out:0</i></b>», так же в свойствах блока нужно
      указать тип контакта – «<b>float</b>» (см. Рис. 4.3)</p>
    <p><image href="labwork8/image066.png" height="277" width="310" id="image_cp4_nj2_qy"
      /></p>
    <p>Рис. 4.3. Настройка контакта в будущее dll</p>
    <p>В результате доработки схема должна выглядеть как рисунке 4.4</p>
    <p><image href="labwork8/image067.jpg" height="388" width="914" id="image_dp4_nj2_qy"
      /></p>
    <p>Рис. 4.4. Схема алгоритма подготовленная для генерации кода Си</p>
    <p>Определим название для нашей будущей dll. Вызовем параметры расчета схемы (кнопочка <image
        href="labwork8/image068.png" height="21" width="23" id="image_ep4_nj2_qy"/> в верху
      схемы, справа)(см. Рис. 4.4), и зададим имя алгоритма как
          «<b><i>fl_</i></b><b><i>controller</i></b>» (cм. Рис. 4.5)</p>
    <p><image href="labwork8/image069.png" height="94" width="400" id="image_fp4_nj2_qy"/></p>
    <p>Рис. 4.5 настройка имени dll</p>
    <p>Перейдем к настройкам генератора кода. В главном меню программы выбираем пункт
        «<i>Кодогенератор</i>», на закладке «<i>Настройки</i>», выбираем «Директория шаблонов кода»,
      WinGW_DLL, если у вас 32 разрядный SimInTech или WinGW_DLL_x64, если у вас 64 разрядный
      SimInTech. (см. Рис 4.6)</p>
    <p>Если вы используете Linux или, не приведи господь QNX, вы лучше меня знаете что там и про
      что.</p>
    <p><image href="labwork8/image070.jpg" height="274" width="382" id="image_gp4_nj2_qy"
      /></p>
    <p>Рис. 4.6 Настройка кодогенератора</p>
    <p>Сохраняем проект вы главном меню пункт «<i>Инструменты</i>» выбираем подпункт «Сгенерировать
      программу». И скорее всего вы увидите вот такое окно (см. рис. 4.7), где вам сообщат, что у
      вас не установлены компилятор MinGW, и добрые разработчики SimInTech специально для вас
      выложили ссылку, откуда вы можете его скачать.</p>
    <p>Но несмотря, на то что компилятора нет, сам код сгенерировался и вы можете найти его в папке
      проекта. Пока качается компилятор, вы можете посмотреть как выглядит ваш проект записанный в
      коде Cи и даже найти там блоки, которые мы создали. (см. рис. 4.8)</p>
    <p>Только что, вы сгенерировали код Си сертифицированный для использования в системах управления
      важных для безопасности АЭС.</p>
    <p><image href="labwork8/image071.jpg" height="452" width="667" id="image_hp4_nj2_qy"
      /></p>
    <p>Рис. 4.7 Окно с ссылками для загрузки компилятора</p>
    <p> </p>
    <p> </p>
    <table id="table_ip4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image072.jpg" height="223" width="411"
                id="image_jp4_nj2_qy"/></entry>
            <entry><image href="labwork8/image073.png" height="272" width="515"
                id="image_kp4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис. 4.8 Код, сгенерированный из SimInTech</entry>
            <entry>Рис. 4.9 Настройка блока «Внешняя dll»</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>После установки компилятора, снова выберете в главном окне «<i>Инструменты</i>» -
      «Сгенерировать программу». Если все установлено правильно, в папке появиться готовый файл с
      именем fl_controller.dll. Поздравляют вы только что сделали блок управления на базе нечеткой
      логики запрограммировали его на Си и собрали в динамическую библиотеку. Программист больше не
      нужен!</p>
    <p>Что бы убедиться, что он работает именно так же войдите в общую модель и удалите субмодель
      «Блок управления на основе нечеткой логики», вместо него разместить блок «<i>Внешняя
        </i><i>dll</i>» из закладки «<i>Субстуркутуры</i>». В настройках блока мы меняем следующие
      параметры (см. рис 4.9):</p>
    <p>Количество портов – <b>2</b> – два входа, которые мы отправляли в схему из модели</p>
    <p>Массив размерностей выходов <b>[1]</b> – у нас один выход с размерностью 1.</p>
    <p>Имена загружаемых dll – <b>fl</b><b>_</b><b>controller</b><b>.</b><b>dll</b> имя файла
      созданной автоматически dll.</p>
    <p>Имена файлов проектов для отладки – <b>fl_controller.prt</b> имя проекта из которого мы
      создавали dll.</p>
    <p> </p>
    <p> </p>
    <p>Подключаем настроенный блок в модель так что бы получилась схема как на рис. 4.10. и
      сохраняем ее под другим именем.</p>
    <p><image href="labwork8/image074.jpg" height="213" width="569" id="image_lp4_nj2_qy"
      /></p>
    <p>Рисунок 4.10 Схема модели с логикой управления подключенной как внешяя dll</p>
    <p>Запуская модель на расчет мы можем убедиться, что работает система управления абсолютно так
      же как созданная в виде схемы. Если вы все делали согласно методическим указаниям, то все
      файлы находятся в одной директории, и при расчете в режиме синхронизации с реальным временем
      вы можете путем двойного клика на блоке DLL вызвать схему из которой был собрана dll наблюдать
      за моделированием, так же как и при стандартном моделировании схемы. При это вызываемая схема
      отображает значения как на линиях связи, может строить графики, а так же работает анимация
      блоков созданная ранее (см. Рис. 4.11).</p>
    <p>Если же вы не передаете исходную схему моделирование происходит в режиме черного ящика.</p>
    <p>Для сравнения скорости расчета в виде схемы и в виде скомпилированного кода снимите галочку
        «<i>Синхронизировать с реальным временем</i>» в параметрах расчета основной модели (кнопочка
        <image href="labwork8/image075.png" height="21" width="23" id="image_mp4_nj2_qy"/> в
      верху схемы, справа) (рис. 4.12).</p>
    <p><image href="labwork8/image076.jpg" height="524" width="882" id="image_np4_nj2_qy"
      /></p>
    <p>Рисунок 4.11 Отображения работы dll на схеме-источнике.</p>
    <p> </p>
    <table id="table_op4_nj2_qy">
      <tgroup cols="2">
        <colspec colnum="1" colname="col1"/>
        <colspec colnum="2" colname="col2"/>
        <tbody>
          <row>
            <entry><image href="labwork8/image077.jpg" height="122" width="304"
                id="image_pp4_nj2_qy"/></entry>
            <entry><image href="labwork8/image078.jpg" height="223" width="635"
                id="image_qp4_nj2_qy"/></entry>
          </row>
          <row>
            <entry>Рис. 4.12 Отмена синхронизации при расчете модели</entry>
            <entry>Рис. 4.13 Сравнение скорости расчет dll и схемы</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <p>Запустите на расчет модель. Посчитает мгновенно, но если зайти в главное окно пункт меню
        «<i>Расчет</i>» подпункт «<i>Отладочная информация</i>», то коэффициент ускорения, покажет
      во сколько раз быстрее реального времени рассчитана модель. На рисунке 4.13 показана сравнение
      скорости модели нечеткой логики в виде схемы и в виде dll, в данном случае выигрыш dll
      составляет более чем в 200 раз.</p>
    <p> </p>
    <p><b>Заключение</b></p>
    <p>Только что на ваших глазах, мы сделали набор блоков, который в Simulink выделен в отдельны
      ToolBox и продается за нормальные деньги. Данная лабораторная работа показывает, что с помощью
      инструмента SimInTech можно решить любые задачи для моделирования, упаковать модели в dll и
      продавать их как отдельные продукты. Удачи!</p>
  </body>
</topic>
